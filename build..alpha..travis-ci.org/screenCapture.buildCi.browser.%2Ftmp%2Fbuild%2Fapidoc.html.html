<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/hij1nx/EventEmitter2#readme">eventemitter2 (v4.1.0)</a>
</h1>
<h4>A Node.js event emitter implementation with namespaces, wildcards, TTL and browser support.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventemitter2">module eventemitter2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.eventemitter2">
            function <span class="apidocSignatureSpan"></span>eventemitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2">
            function <span class="apidocSignatureSpan">eventemitter2.</span>EventEmitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eventemitter2.</span>EventEmitter2.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventemitter2.EventEmitter2">module eventemitter2.EventEmitter2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.EventEmitter2">
            function <span class="apidocSignatureSpan">eventemitter2.</span>EventEmitter2
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eventemitter2.EventEmitter2.prototype">module eventemitter2.EventEmitter2.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype._many">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_many
            <span class="apidocSignatureSpan">(event, ttl, fn, prepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype._on">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_on
            <span class="apidocSignatureSpan">(type, listener, prepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype._onAny">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_onAny
            <span class="apidocSignatureSpan">(fn, prepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype._once">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_once
            <span class="apidocSignatureSpan">(event, fn, prepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.addListener">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.emit">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.emitAsync">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>emitAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.eventNames">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listenerCount">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listeners">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listenersAny">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listenersAny
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.many">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>many
            <span class="apidocSignatureSpan">(event, ttl, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.off">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>off
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.offAny">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>offAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.on">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.onAny">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>onAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.once">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependAny">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependAny
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependListener">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependMany">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependMany
            <span class="apidocSignatureSpan">(event, ttl, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependOnceListener">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependOnceListener
            <span class="apidocSignatureSpan">(event, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.removeListener">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eventemitter2.EventEmitter2.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>delimiter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>event</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventemitter2" id="apidoc.module.eventemitter2">module eventemitter2</a></h1>


    <h2>
        <a href="#apidoc.element.eventemitter2.eventemitter2" id="apidoc.element.eventemitter2.eventemitter2">
        function <span class="apidocSignatureSpan"></span>eventemitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = {};
  this.newListener = false;
  this.verboseMemoryLeak = false;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2" id="apidoc.element.eventemitter2.EventEmitter2">
        function <span class="apidocSignatureSpan">eventemitter2.</span>EventEmitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = {};
  this.newListener = false;
  this.verboseMemoryLeak = false;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventemitter2.EventEmitter2" id="apidoc.module.eventemitter2.EventEmitter2">module eventemitter2.EventEmitter2</a></h1>


    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.EventEmitter2" id="apidoc.element.eventemitter2.EventEmitter2.EventEmitter2">
        function <span class="apidocSignatureSpan">eventemitter2.</span>EventEmitter2
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(conf) {
  this._events = {};
  this.newListener = false;
  this.verboseMemoryLeak = false;
  configure.call(this, conf);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eventemitter2.EventEmitter2.prototype" id="apidoc.module.eventemitter2.EventEmitter2.prototype">module eventemitter2.EventEmitter2.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype._many" id="apidoc.element.eventemitter2.EventEmitter2.prototype._many">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_many
        <span class="apidocSignatureSpan">(event, ttl, fn, prepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_many = function (event, ttl, fn, prepend) {
  var self = this;

  if (typeof fn !== 'function') {
    throw new Error('many only accepts instances of Function');
  }

  function listener() {
    if (--ttl === 0) {
      self.off(event, listener);
    }
    return fn.apply(this, arguments);
  }

  listener._origin = fn;

  this._on(event, listener, prepend);

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype._on" id="apidoc.element.eventemitter2.EventEmitter2.prototype._on">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_on
        <span class="apidocSignatureSpan">(type, listener, prepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_on = function (type, listener, prepend) {
  if (typeof type === 'function') {
    this._onAny(type, listener);
    return this;
  }

  if (typeof listener !== 'function') {
    throw new Error('on only accepts instances of Function');
  }
  this._events || init.call(this);

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (this.wildcard) {
    growListenerTree.call(this, type, listener);
    return this;
  }

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  }
  else {
    if (typeof this._events[type] === 'function') {
      // Change to array.
      this._events[type] = [this._events[type]];
    }

    // If we've already got an array, just add
    if(prepend){
      this._events[type].unshift(listener);
    }else{
      this._events[type].push(listener);
    }

    // Check for listener leak
    if (
      !this._events[type].warned &amp;&amp;
      this._maxListeners &gt; 0 &amp;&amp;
      this._events[type].length &gt; this._maxListeners
    ) {
      this._events[type].warned = true;
      logPossibleMemoryLeak.call(this, this._events[type].length, type);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype._onAny" id="apidoc.element.eventemitter2.EventEmitter2.prototype._onAny">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_onAny
        <span class="apidocSignatureSpan">(fn, prepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_onAny = function (fn, prepend){
  if (typeof fn !== 'function') {
    throw new Error('onAny only accepts instances of Function');
  }

  if (!this._all) {
    this._all = [];
  }

  // Add the function to the event listener collection.
  if(prepend){
    this._all.unshift(fn);
  }else{
    this._all.push(fn);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype._once" id="apidoc.element.eventemitter2.EventEmitter2.prototype._once">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>_once
        <span class="apidocSignatureSpan">(event, fn, prepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_once = function (event, fn, prepend) {
  this._many(event, 1, fn, prepend);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.addListener" id="apidoc.element.eventemitter2.EventEmitter2.prototype.addListener">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (type, listener) {
  return this._on(type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
emitter.emit('foo.bar');
emitter.emit('foo.bar.baz');
````

On the other hand, if the single-wildcard event name was passed to the on method, the callback would only observe the second of
these events.


### emitter.<span class="apidocCodeKeywordSpan">addListener</span>(event, listener)
### emitter.on(event, listener)

Adds a listener to the end of the listeners array for the specified event.

```javascript
server.on('data', function(value1, value2, value3, ...) {
  console.log('The event was raised!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.emit" id="apidoc.element.eventemitter2.EventEmitter2.prototype.emit">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {

  this._events || init.call(this);

  var type = arguments[0];

  if (type === 'newListener' &amp;&amp; !this.newListener) {
    if (!this._events.newListener) {
      return false;
    }
  }

  var al = arguments.length;
  var args,l,i,j;
  var handler;

  if (this._all &amp;&amp; this._all.length) {
    handler = this._all.slice();
    if (al &gt; 3) {
      args = new Array(al);
      for (j = 0; j &lt; al; j++) args[j] = arguments[j];
    }

    for (i = 0, l = handler.length; i &lt; l; i++) {
      this.event = type;
      switch (al) {
      case 1:
        handler[i].call(this, type);
        break;
      case 2:
        handler[i].call(this, type, arguments[1]);
        break;
      case 3:
        handler[i].call(this, type, arguments[1], arguments[2]);
        break;
      default:
        handler[i].apply(this, args);
      }
    }
  }

  if (this.wildcard) {
    handler = [];
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
  } else {
    handler = this._events[type];
    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j &lt; al; j++) args[j - 1] = arguments[j];
        handler.apply(this, args);
      }
      return true;
    } else if (handler) {
      // need to make copy of handlers because list can change in the middle
      // of emit call
      handler = handler.slice();
    }
  }

  if (handler &amp;&amp; handler.length) {
    if (al &gt; 3) {
      args = new Array(al - 1);
      for (j = 1; j &lt; al; j++) args[j - 1] = arguments[j];
    }
    for (i = 0, l = handler.length; i &lt; l; i++) {
      this.event = type;
      switch (al) {
      case 1:
        handler[i].call(this);
        break;
      case 2:
        handler[i].call(this, arguments[1]);
        break;
      case 3:
        handler[i].call(this, arguments[1], arguments[2]);
        break;
      default:
        handler[i].apply(this, args);
      }
    }
    return true;
  } else if (!this._all &amp;&amp; type === 'error') {
    if (arguments[1] instanceof Error) {
      throw arguments[1]; // Unhandled 'error' event
    } else {
      throw new Error("Uncaught, unspecified 'error' event.");
    }
    return false;
  }

  return !!this._all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`*` character). If the event name is a string, a wildcard may appear as `foo.*`.
If the event name is an array, the wildcard may appear as `['foo', '*']`.

If either of the above described events were passed to the `on` method,
subsequent emits such as the following would be observed...

```javascript
   emitter.<span class="apidocCodeKeywordSpan">emit</span>('foo.bazz');
   emitter.emit(['foo', 'bar']);
```

# Multi-level Wildcards
A double wildcard (the string `**`) matches any number of levels (zero or more) of events. So if for example `'foo.**'`
is passed to the `on` method, the following events would be observed:

````javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.emitAsync" id="apidoc.element.eventemitter2.EventEmitter2.prototype.emitAsync">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>emitAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emitAsync = function () {

  this._events || init.call(this);

  var type = arguments[0];

  if (type === 'newListener' &amp;&amp; !this.newListener) {
      if (!this._events.newListener) { return Promise.resolve([false]); }
  }

  var promises= [];

  var al = arguments.length;
  var args,l,i,j;
  var handler;

  if (this._all) {
    if (al &gt; 3) {
      args = new Array(al);
      for (j = 1; j &lt; al; j++) args[j] = arguments[j];
    }
    for (i = 0, l = this._all.length; i &lt; l; i++) {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(this._all[i].call(this, type));
        break;
      case 2:
        promises.push(this._all[i].call(this, type, arguments[1]));
        break;
      case 3:
        promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
        break;
      default:
        promises.push(this._all[i].apply(this, args));
      }
    }
  }

  if (this.wildcard) {
    handler = [];
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
  } else {
    handler = this._events[type];
  }

  if (typeof handler === 'function') {
    this.event = type;
    switch (al) {
    case 1:
      promises.push(handler.call(this));
      break;
    case 2:
      promises.push(handler.call(this, arguments[1]));
      break;
    case 3:
      promises.push(handler.call(this, arguments[1], arguments[2]));
      break;
    default:
      args = new Array(al - 1);
      for (j = 1; j &lt; al; j++) args[j - 1] = arguments[j];
      promises.push(handler.apply(this, args));
    }
  } else if (handler &amp;&amp; handler.length) {
    handler = handler.slice();
    if (al &gt; 3) {
      args = new Array(al - 1);
      for (j = 1; j &lt; al; j++) args[j - 1] = arguments[j];
    }
    for (i = 0, l = handler.length; i &lt; l; i++) {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler[i].call(this));
        break;
      case 2:
        promises.push(handler[i].call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler[i].call(this, arguments[1], arguments[2]));
        break;
      default:
        promises.push(handler[i].apply(this, args));
      }
    }
  } else if (!this._all &amp;&amp; type === 'error') {
    if (arguments[1] instanceof Error) {
      return Promise.reject(arguments[1]); // Unhandled 'error' event
    } else {
      return Promise.reject("Uncaught, unspecified 'error' event.");
    }
  }

  return Promise.all(promises);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### emitter.emit(event, [arg1], [arg2], [...])

Execute each of the listeners that may be listening for the specified event
name in order with the list of arguments.

### emitter.<span class="apidocCodeKeywordSpan">emitAsync</span>(event, [arg1], [arg2], [...])

Return the results of the listeners via [Promise.all](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects
/Promise/all).
Only this method doesn't work [IE](http://caniuse.com/#search=promise).

```javascript
emitter.on('get',function(i) {
  return new Promise(function(resolve){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.eventNames" id="apidoc.element.eventemitter2.EventEmitter2.prototype.eventNames">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventNames = function (){
  return Object.keys(this._events);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

emitter.emitAsync('get',0)
.then(function(results){
  console.log(results); // [3,2,1,0,undefined]
});
```

### emitter.<span class="apidocCodeKeywordSpan">eventNames</span>()

Returns an array listing the events for which the emitter has registered listeners. The values in the array will be strings.

```javascript
emitter.on('foo', () =&gt; {});
emitter.on('bar', () =&gt; {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listenerCount" id="apidoc.element.eventemitter2.EventEmitter2.prototype.listenerCount">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerCount = function (type) {
  return this.listeners(type).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listeners" id="apidoc.element.eventemitter2.EventEmitter2.prototype.listeners">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function (type) {
  if (this.wildcard) {
    var handlers = [];
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
    return handlers;
  }

  this._events || init.call(this);

  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

By default EventEmitters will print a warning if more than 10 listeners
are added to it. This is a useful default which helps finding memory leaks.
Obviously not all Emitters should be limited to 10. This function allows
that to be increased. Set to zero for unlimited.


### emitter.<span class="apidocCodeKeywordSpan">listeners</span>(event)

Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.

```javascript
server.on('get', function(value) {
  console.log('someone connected!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.listenersAny" id="apidoc.element.eventemitter2.EventEmitter2.prototype.listenersAny">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>listenersAny
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenersAny = function () {

  if(this._all) {
    return this._all;
  }
  else {
    return [];
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
server.on('get', function(value) {
  console.log('someone connected!');
});
console.log(server.listeners('get')); // [ [Function] ]
```

### emitter.<span class="apidocCodeKeywordSpan">listenersAny</span>()

Returns an array of listeners that are listening for any event that is
specified. This array can be manipulated, e.g. to remove listeners.

```javascript
server.onAny(function(value) {
  console.log('someone connected!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.many" id="apidoc.element.eventemitter2.EventEmitter2.prototype.many">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>many
        <span class="apidocSignatureSpan">(event, ttl, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">many = function (event, ttl, fn) {
  return this._many(event, ttl, fn, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      console.log(this.event, value1, value2);
    });
```

 - Fire an event N times and then remove it, an extension of the `once` concept.

```javascript
    server.<span class="apidocCodeKeywordSpan">many</span>('foo', 4, function() {
      console.log('hello');
    });
```

 - Pass in a namespaced event as an array rather than a delimited string.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.off" id="apidoc.element.eventemitter2.EventEmitter2.prototype.off">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>off
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (type, listener) {
  if (typeof listener !== 'function') {
    throw new Error('removeListener only takes instances of Function');
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &lt; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &amp;&amp; handlers[i].listener === listener) ||
          (handlers[i]._origin &amp;&amp; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &lt; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }

      this.emit("removeListener", type, listener);

      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &amp;&amp; handlers.listener === listener) ||
      (handlers._origin &amp;&amp; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }

      this.emit("removeListener", type, listener);
    }
  }

  function recursivelyGarbageCollect(root) {
    if (root === undefined) {
      return;
    }
    var keys = Object.keys(root);
    for (var i in keys) {
      var key = keys[i];
      var obj = root[key];
      if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
        continue;
      if (Object.keys(obj).length &gt; 0) {
        recursivelyGarbageCollect(root[key]);
      }
      if (Object.keys(obj).length === 0) {
        delete root[key];
      }
    }
  }
  recursivelyGarbageCollect(this.listenerTree);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  console.log('This event will be listened to exactly four times.');
});
```



### emitter.removeListener(event, listener)
### emitter.<span class="apidocCodeKeywordSpan">off</span>(event, listener)

Remove a listener from the listener array for the specified event.
**Caution**: Calling this method changes the array indices in the listener array behind the listener.

```javascript
var callback = function(value) {
  console.log('someone connected!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.offAny" id="apidoc.element.eventemitter2.EventEmitter2.prototype.offAny">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>offAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">offAny = function (fn) {
  var i = 0, l = 0, fns;
  if (fn &amp;&amp; this._all &amp;&amp; this._all.length &gt; 0) {
    fns = this._all;
    for(i = 0, l = fns.length; i &lt; l; i++) {
      if(fn === fns[i]) {
        fns.splice(i, 1);
        this.emit("removeListenerAny", fn);
        return this;
      }
    }
  } else {
    fns = this._all;
    for(i = 0, l = fns.length; i &lt; l; i++)
      this.emit("removeListenerAny", fns[i]);
    this._all = [];
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
server.prependAny(function(event, value) {
  console.log('All events trigger this.');
});
```

### emitter.<span class="apidocCodeKeywordSpan">offAny</span>(listener)

Removes the listener that will be fired when any event is emitted.

```javascript
server.offAny(function(value) {
  console.log('The event was raised!');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.on" id="apidoc.element.eventemitter2.EventEmitter2.prototype.on">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener) {
  return this._on(type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      verboseMemoryLeak: false
    });
```

 - Getting the actual event that fired.

```javascript
    server.<span class="apidocCodeKeywordSpan">on</span>('foo.*', function(value1, value2) {
      console.log(this.event, value1, value2);
    });
```

 - Fire an event N times and then remove it, an extension of the `once` concept.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.onAny" id="apidoc.element.eventemitter2.EventEmitter2.prototype.onAny">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>onAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onAny = function (fn) {
  return this._onAny(fn, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
server.prependListener('data', function(value1, value2, value3, ...) {
  console.log('The event was raised!');
});
```


### emitter.<span class="apidocCodeKeywordSpan">onAny</span>(listener)

Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the callback.

```javascript
server.onAny(function(event, value) {
  console.log('All events trigger this.');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.once" id="apidoc.element.eventemitter2.EventEmitter2.prototype.once">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, fn) {
  return this._once(event, fn, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
server.offAny(function(value) {
  console.log('The event was raised!');
});
```

#### emitter.<span class="apidocCodeKeywordSpan">once</span>(event, listener)

Adds a **one time** listener for the event. The listener is invoked
only the first time the event is fired, after which it is removed.

```javascript
server.once('get', function (value) {
  console.log('Ah, we have our first value!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependAny" id="apidoc.element.eventemitter2.EventEmitter2.prototype.prependAny">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependAny
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependAny = function (fn) {
  return this._onAny(fn, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
server.onAny(function(event, value) {
  console.log('All events trigger this.');
});
```

### emitter.<span class="apidocCodeKeywordSpan">prependAny</span>(listener)

Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the callback. The
 listener is added to the beginning of the listeners array

```javascript
server.prependAny(function(event, value) {
  console.log('All events trigger this.');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependListener" id="apidoc.element.eventemitter2.EventEmitter2.prototype.prependListener">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependListener = function (type, listener) {
  return this._on(type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
server.on('data', function(value) {
  console.log('The event was raised!');
});
```

### emitter.<span class="apidocCodeKeywordSpan">prependListener</span>(event, listener)

Adds a listener to the beginning of the listeners array for the specified event.

```javascript
server.prependListener('data', function(value1, value2, value3, ...) {
  console.log('The event was raised!');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependMany" id="apidoc.element.eventemitter2.EventEmitter2.prototype.prependMany">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependMany
        <span class="apidocSignatureSpan">(event, ttl, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependMany = function (event, ttl, fn) {
  return this._many(event, ttl, fn, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
    server.many('get', 4, function (value) {
      console.log('This event will be listened to exactly four times.');
    });
```

### emitter.<span class="apidocCodeKeywordSpan">prependMany</span>(event, timesToListen, listener)

Adds a listener that will execute **n times** for the event before being
removed. The listener is invoked only the first **n times** the event is
fired, after which it is removed.
The listener is added to the beginning of the listeners array.

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.prependOnceListener" id="apidoc.element.eventemitter2.EventEmitter2.prototype.prependOnceListener">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>prependOnceListener
        <span class="apidocSignatureSpan">(event, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependOnceListener = function (event, fn) {
  return this._once(event, fn, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
server.once('get', function (value) {
  console.log('Ah, we have our first value!');
});
```

#### emitter.<span class="apidocCodeKeywordSpan">prependOnceListener</span>(event, listener)

Adds a **one time** listener for the event. The listener is invoked
only the first time the event is fired, after which it is removed.
The listener is added to the beginning of the listeners array

```javascript
server.prependOnceListener('get', function (value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.removeAllListeners" id="apidoc.element.eventemitter2.EventEmitter2.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (type) {
  if (arguments.length === 0) {
    !this._events || init.call(this);
    return this;
  }

  if (this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

    for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      leaf._listeners = null;
    }
  }
  else if (this._events) {
    this._events[type] = null;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };
    server.on('get', callback);
    // ...
    server.removeListener('get', callback);
```


### emitter.<span class="apidocCodeKeywordSpan">removeAllListeners</span>([event])

Removes all listeners, or those of the specified event.


### emitter.setMaxListeners(n)

By default EventEmitters will print a warning if more than 10 listeners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.removeListener" id="apidoc.element.eventemitter2.EventEmitter2.prototype.removeListener">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
  if (typeof listener !== 'function') {
    throw new Error('removeListener only takes instances of Function');
  }

  var handlers,leafs=[];

  if(this.wildcard) {
    var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
    leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
  }
  else {
    // does not use listeners(), so no side effect of creating _events[type]
    if (!this._events[type]) return this;
    handlers = this._events[type];
    leafs.push({_listeners:handlers});
  }

  for (var iLeaf=0; iLeaf&lt;leafs.length; iLeaf++) {
    var leaf = leafs[iLeaf];
    handlers = leaf._listeners;
    if (isArray(handlers)) {

      var position = -1;

      for (var i = 0, length = handlers.length; i &lt; length; i++) {
        if (handlers[i] === listener ||
          (handlers[i].listener &amp;&amp; handlers[i].listener === listener) ||
          (handlers[i]._origin &amp;&amp; handlers[i]._origin === listener)) {
          position = i;
          break;
        }
      }

      if (position &lt; 0) {
        continue;
      }

      if(this.wildcard) {
        leaf._listeners.splice(position, 1);
      }
      else {
        this._events[type].splice(position, 1);
      }

      if (handlers.length === 0) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }

      this.emit("removeListener", type, listener);

      return this;
    }
    else if (handlers === listener ||
      (handlers.listener &amp;&amp; handlers.listener === listener) ||
      (handlers._origin &amp;&amp; handlers._origin === listener)) {
      if(this.wildcard) {
        delete leaf._listeners;
      }
      else {
        delete this._events[type];
      }

      this.emit("removeListener", type, listener);
    }
  }

  function recursivelyGarbageCollect(root) {
    if (root === undefined) {
      return;
    }
    var keys = Object.keys(root);
    for (var i in keys) {
      var key = keys[i];
      var obj = root[key];
      if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
        continue;
      if (Object.keys(obj).length &gt; 0) {
        recursivelyGarbageCollect(root[key]);
      }
      if (Object.keys(obj).length === 0) {
        delete root[key];
      }
    }
  }
  recursivelyGarbageCollect(this.listenerTree);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
server.many('get', 4, function (value) {
  console.log('This event will be listened to exactly four times.');
});
```



### emitter.<span class="apidocCodeKeywordSpan">removeListener</span>(event, listener)
### emitter.off(event, listener)

Remove a listener from the listener array for the specified event.
**Caution**: Calling this method changes the array indices in the listener array behind the listener.

```javascript
var callback = function(value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eventemitter2.EventEmitter2.prototype.setMaxListeners" id="apidoc.element.eventemitter2.EventEmitter2.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">eventemitter2.EventEmitter2.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function (n) {
  if (n !== undefined) {
    this._maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


### emitter.removeAllListeners([event])

Removes all listeners, or those of the specified event.


### emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>(n)

By default EventEmitters will print a warning if more than 10 listeners
are added to it. This is a useful default which helps finding memory leaks.
Obviously not all Emitters should be limited to 10. This function allows
that to be increased. Set to zero for unlimited.
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>